import {
  MaterialDefines,
  PushMaterial,
  RawTexture
} from "./chunk-J7BCWB2R.js";
import {
  BindFogParameters,
  BindLogDepth,
  Camera,
  Mesh,
  PrepareAttributesForInstances,
  PrepareDefinesForAttributes,
  PrepareDefinesForFrameBoundValues,
  PrepareDefinesForMisc,
  PrepareUniformsAndSamplersList,
  SubMesh,
  VertexData,
  addClipPlaneUniforms,
  bindClipPlane
} from "./chunk-JFPCGYH4.js";
import {
  Logger,
  Matrix,
  Quaternion,
  RegisterClass,
  SerializationHelper,
  ShaderStore,
  TmpVectors,
  Tools,
  Vector2,
  Vector3,
  VertexBuffer
} from "./chunk-RFTLRIJF.js";

// node_modules/@babylonjs/core/Shaders/gaussianSplatting.fragment.js
var name = "gaussianSplattingPixelShader";
var shader = `#include<clipPlaneFragmentDeclaration>
#include<logDepthDeclaration>
#include<fogFragmentDeclaration>
varying vec4 vColor;varying vec2 vPosition;void main () { 
#include<clipPlaneFragment>
float A=-dot(vPosition,vPosition);if (A<-4.0) discard;float B=exp(A)*vColor.a;
#include<logDepthFragment>
vec3 color=vColor.rgb;
#ifdef FOG
#include<fogFragment>
#endif
gl_FragColor=vec4(color,B);}
`;
ShaderStore.ShadersStore[name] = shader;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/gaussianSplattingVertexDeclaration.js
var name2 = "gaussianSplattingVertexDeclaration";
var shader2 = `uniform mat4 world;uniform mat4 view;uniform mat4 projection;
`;
ShaderStore.IncludesShadersStore[name2] = shader2;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/gaussianSplattingUboDeclaration.js
var name3 = "gaussianSplattingUboDeclaration";
var shader3 = `#include<sceneUboDeclaration>
#include<meshUboDeclaration>
`;
ShaderStore.IncludesShadersStore[name3] = shader3;

// node_modules/@babylonjs/core/Shaders/gaussianSplatting.vertex.js
var name4 = "gaussianSplattingVertexShader";
var shader4 = `#include<__decl__gaussianSplattingVertex>
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
#include<clipPlaneVertexDeclaration>
#include<fogVertexDeclaration>
#include<logDepthDeclaration>
attribute vec2 position;attribute float splatIndex;uniform vec2 viewport;uniform vec2 dataTextureSize;uniform vec2 focal;uniform sampler2D covariancesATexture;uniform sampler2D covariancesBTexture;uniform sampler2D centersTexture;uniform sampler2D colorsTexture;varying vec4 vColor;varying vec2 vPosition;
#if !defined(WEBGL2) && !defined(WEBGPU) && !defined(NATIVE)
mat3 transpose(mat3 matrix) {return mat3(matrix[0][0],matrix[1][0],matrix[2][0],
matrix[0][1],matrix[1][1],matrix[2][1],
matrix[0][2],matrix[1][2],matrix[2][2]);}
#endif
vec2 getDataUV(float index,vec2 textureSize) {float y=floor(index/textureSize.x);float x=index-y*textureSize.x;return vec2((x+0.5)/textureSize.x,(y+0.5)/textureSize.y);}
void main () {vec2 splatUV=getDataUV(splatIndex,dataTextureSize);vec3 center=texture2D(centersTexture,splatUV).xyz;vec4 color=texture2D(colorsTexture,splatUV);vec3 covA=texture2D(covariancesATexture,splatUV).xyz;vec3 covB=texture2D(covariancesBTexture,splatUV).xyz;vec4 worldPos=world*vec4(center,1.0);mat4 modelView=view*world;vec4 camspace=view*worldPos;vec4 pos2d=projection*camspace;float bounds=1.2*pos2d.w;if (pos2d.z<-pos2d.w || pos2d.x<-bounds || pos2d.x>bounds
|| pos2d.y<-bounds || pos2d.y>bounds) {gl_Position=vec4(0.0,0.0,2.0,1.0);return;}
mat3 Vrk=mat3(
covA.x,covA.y,covA.z,
covA.y,covB.x,covB.y,
covA.z,covB.y,covB.z
);mat3 J=mat3(
focal.x/camspace.z,0.,-(focal.x*camspace.x)/(camspace.z*camspace.z),
0.,focal.y/camspace.z,-(focal.y*camspace.y)/(camspace.z*camspace.z),
0.,0.,0.
);mat3 invy=mat3(1,0,0,0,-1,0,0,0,1);mat3 T=invy*transpose(mat3(modelView))*J;mat3 cov2d=transpose(T)*Vrk*T;float mid=(cov2d[0][0]+cov2d[1][1])/2.0;float radius=length(vec2((cov2d[0][0]-cov2d[1][1])/2.0,cov2d[0][1]));float lambda1=mid+radius,lambda2=mid-radius;if (lambda2<0.0) return;vec2 diagonalVector=normalize(vec2(cov2d[0][1],lambda1-cov2d[0][0]));vec2 majorAxis=min(sqrt(2.0*lambda1),1024.0)*diagonalVector;vec2 minorAxis=min(sqrt(2.0*lambda2),1024.0)*vec2(diagonalVector.y,-diagonalVector.x);vColor=color;vPosition=position;vec2 vCenter=vec2(pos2d);gl_Position=vec4(
vCenter 
+ (position.x*majorAxis*1./viewport 
+ position.y*minorAxis*1./viewport)*pos2d.w,pos2d.zw);
#include<clipPlaneVertex>
#include<fogVertex>
#include<logDepthVertex>
}
`;
ShaderStore.ShadersStore[name4] = shader4;

// node_modules/@babylonjs/core/Materials/GaussianSplatting/gaussianSplattingMaterial.js
var GaussianSplattingMaterialDefines = class extends MaterialDefines {
  /**
   * Constructor of the defines.
   */
  constructor() {
    super();
    this.FOG = false;
    this.THIN_INSTANCES = true;
    this.LOGARITHMICDEPTH = false;
    this.CLIPPLANE = false;
    this.CLIPPLANE2 = false;
    this.CLIPPLANE3 = false;
    this.CLIPPLANE4 = false;
    this.CLIPPLANE5 = false;
    this.CLIPPLANE6 = false;
    this.rebuild();
  }
};
var GaussianSplattingMaterial = class _GaussianSplattingMaterial extends PushMaterial {
  /**
   * Instantiates a Gaussian Splatting Material in the given scene
   * @param name The friendly name of the material
   * @param scene The scene to add the material to
   */
  constructor(name5, scene) {
    super(name5, scene);
    this.backFaceCulling = false;
  }
  /**
   * Gets a boolean indicating that current material needs to register RTT
   */
  get hasRenderTargetTextures() {
    return false;
  }
  /**
   * Specifies whether or not this material should be rendered in alpha test mode.
   * @returns false
   */
  needAlphaTesting() {
    return false;
  }
  /**
   * Specifies whether or not this material should be rendered in alpha blend mode.
   * @returns true
   */
  needAlphaBlending() {
    return true;
  }
  /**
   * Checks whether the material is ready to be rendered for a given mesh.
   * @param mesh The mesh to render
   * @param subMesh The submesh to check against
   * @returns true if all the dependencies are ready (Textures, Effects...)
   */
  isReadyForSubMesh(mesh, subMesh) {
    const useInstances = true;
    const drawWrapper = subMesh._drawWrapper;
    if (drawWrapper.effect && this.isFrozen) {
      if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new GaussianSplattingMaterialDefines();
    }
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, false, defines);
    PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances, null, true);
    PrepareDefinesForAttributes(mesh, defines, false, false);
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const attribs = [VertexBuffer.PositionKind, "splatIndex"];
      PrepareAttributesForInstances(attribs, defines);
      const uniforms = ["world", "view", "projection", "vFogInfos", "vFogColor", "logarithmicDepthConstant", "viewport", "dataTextureSize", "focal"];
      const samplers = ["covariancesATexture", "covariancesBTexture", "centersTexture", "colorsTexture"];
      const uniformBuffers = ["Scene", "Mesh"];
      PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines
      });
      addClipPlaneUniforms(uniforms);
      const join = defines.toString();
      const effect = scene.getEngine().createEffect("gaussianSplatting", {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        onCompiled: this.onCompiled,
        onError: this.onError
      }, engine);
      subMesh.setEffect(effect, defines, this._materialContext);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    drawWrapper._wasPreviouslyUsingInstances = useInstances;
    return true;
  }
  /**
   * Binds the submesh to this material by preparing the effect and shader to draw
   * @param world defines the world transformation matrix
   * @param mesh defines the mesh containing the submesh
   * @param subMesh defines the submesh to bind the material to
   */
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    mesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
    mesh.transferToEffect(world);
    const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);
    if (mustRebind) {
      this.bindView(effect);
      this.bindViewProjection(effect);
      const engine = scene.getEngine();
      const camera = this.getScene().activeCamera;
      const renderWidth = engine.getRenderWidth();
      const renderHeight = engine.getRenderHeight();
      this._activeEffect.setFloat2("viewport", renderWidth, renderHeight);
      let focal = 1e3;
      if (camera) {
        if (camera.fovMode == Camera.FOVMODE_VERTICAL_FIXED) {
          focal = renderHeight / 2 / Math.tan(camera.fov / 2);
        } else {
          focal = renderWidth / 2 / Math.tan(camera.fov / 2);
        }
      }
      this._activeEffect.setFloat2("focal", focal, focal);
      const gsMesh = mesh;
      if (gsMesh.covariancesATexture) {
        const textureSize = gsMesh.covariancesATexture.getSize();
        effect.setFloat2("dataTextureSize", textureSize.width, textureSize.height);
        effect.setTexture("covariancesATexture", gsMesh.covariancesATexture);
        effect.setTexture("covariancesBTexture", gsMesh.covariancesBTexture);
        effect.setTexture("centersTexture", gsMesh.centersTexture);
        effect.setTexture("colorsTexture", gsMesh.colorsTexture);
      }
      bindClipPlane(effect, this, scene);
    } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {
      this._needToBindSceneUbo = true;
    }
    BindFogParameters(scene, mesh, effect);
    if (this.useLogarithmicDepth) {
      BindLogDepth(defines, effect, scene);
    }
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  /**
   * Clones the material.
   * @param name The cloned name.
   * @returns The cloned material.
   */
  clone(name5) {
    return SerializationHelper.Clone(() => new _GaussianSplattingMaterial(name5, this.getScene()), this);
  }
  /**
   * Serializes the current material to its JSON representation.
   * @returns The JSON representation.
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.GaussianSplattingMaterial";
    return serializationObject;
  }
  /**
   * Gets the class name of the material
   * @returns "GaussianSplattingMaterial"
   */
  getClassName() {
    return "GaussianSplattingMaterial";
  }
  /**
   * Parse a JSON input to create back a Gaussian Splatting material.
   * @param source The JSON data to parse
   * @param scene The scene to create the parsed material in
   * @param rootUrl The root url of the assets the material depends upon
   * @returns the instantiated GaussianSplattingMaterial.
   */
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new _GaussianSplattingMaterial(source.name, scene), source, scene, rootUrl);
  }
};
RegisterClass("BABYLON.GaussianSplattingMaterial", GaussianSplattingMaterial);

// node_modules/@babylonjs/core/Meshes/GaussianSplatting/gaussianSplattingMesh.js
var GaussianSplattingMesh = class _GaussianSplattingMesh extends Mesh {
  /**
   * Gets the covariancesA texture
   */
  get covariancesATexture() {
    return this._covariancesATexture;
  }
  /**
   * Gets the covariancesB texture
   */
  get covariancesBTexture() {
    return this._covariancesBTexture;
  }
  /**
   * Gets the centers texture
   */
  get centersTexture() {
    return this._centersTexture;
  }
  /**
   * Gets the colors texture
   */
  get colorsTexture() {
    return this._colorsTexture;
  }
  /**
   * Creates a new gaussian splatting mesh
   * @param name defines the name of the mesh
   * @param url defines the url to load from (optional)
   * @param scene defines the hosting scene (optional)
   */
  constructor(name5, url = null, scene = null) {
    super(name5, scene);
    this._vertexCount = 0;
    this._worker = null;
    this._frameIdLastUpdate = -1;
    this._modelViewMatrix = Matrix.Identity();
    this._material = null;
    this._canPostToWorker = true;
    this._covariancesATexture = null;
    this._covariancesBTexture = null;
    this._centersTexture = null;
    this._colorsTexture = null;
    const vertexData = new VertexData();
    vertexData.positions = [-2, -2, 0, 2, -2, 0, 2, 2, 0, -2, 2, 0];
    vertexData.indices = [0, 1, 2, 0, 2, 3];
    vertexData.applyToMesh(this);
    this.subMeshes = [];
    new SubMesh(0, 0, 4, 0, 6, this);
    this.doNotSyncBoundingInfo = true;
    this.setEnabled(false);
    this._lastProj = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    if (url) {
      this.loadFileAsync(url);
    }
  }
  /**
   * Returns the class name
   * @returns "GaussianSplattingMesh"
   */
  getClassName() {
    return "GaussianSplattingMesh";
  }
  /**
   * Returns the total number of vertices (splats) within the mesh
   * @returns the total number of vertices
   */
  getTotalVertices() {
    return this._vertexCount;
  }
  /**
   * Triggers the draw call for the mesh. Usually, you don't need to call this method by your own because the mesh rendering is handled by the scene rendering manager
   * @param subMesh defines the subMesh to render
   * @param enableAlphaMode defines if alpha mode can be changed
   * @param effectiveMeshReplacement defines an optional mesh used to provide info for the rendering
   * @returns the current mesh
   */
  render(subMesh, enableAlphaMode, effectiveMeshReplacement) {
    if (!this.material) {
      this._material = new GaussianSplattingMaterial(this.name + "_material", this._scene);
      this.material = this._material;
    }
    const frameId = this.getScene().getFrameId();
    if (frameId !== this._frameIdLastUpdate && this._worker && this._scene.activeCamera && this._canPostToWorker) {
      this.getWorldMatrix().multiplyToRef(this._scene.activeCamera.getViewMatrix(), this._modelViewMatrix);
      const dot = this._lastProj[2] * this._modelViewMatrix.m[2] + this._lastProj[6] * this._modelViewMatrix.m[6] + this._lastProj[10] * this._modelViewMatrix.m[10];
      if (Math.abs(dot - 1) >= 0.01) {
        this._frameIdLastUpdate = frameId;
        this._canPostToWorker = false;
        this._lastProj = this._modelViewMatrix.m.slice(0);
        this._worker.postMessage({ view: this._modelViewMatrix.m, depthMix: this._depthMix }, [this._depthMix.buffer]);
      }
    }
    return super.render(subMesh, enableAlphaMode, effectiveMeshReplacement);
  }
  /**
   * Code from https://github.com/dylanebert/gsplat.js/blob/main/src/loaders/PLYLoader.ts Under MIT license
   * Converts a .ply data array buffer to splat
   * if data array buffer is not ply, returns the original buffer
   * @param data the .ply data to load
   * @returns the loaded splat buffer
   */
  static ConvertPLYToSplat(data) {
    const ubuf = new Uint8Array(data);
    const header = new TextDecoder().decode(ubuf.slice(0, 1024 * 10));
    const headerEnd = "end_header\n";
    const headerEndIndex = header.indexOf(headerEnd);
    if (headerEndIndex < 0 || !header) {
      return data;
    }
    const vertexCount = parseInt(/element vertex (\d+)\n/.exec(header)[1]);
    let rowOffset = 0;
    const offsets = {
      double: 8,
      int: 4,
      uint: 4,
      float: 4,
      short: 2,
      ushort: 2,
      uchar: 1
    };
    const properties = [];
    const filtered = header.slice(0, headerEndIndex).split("\n").filter((k) => k.startsWith("property "));
    for (const prop of filtered) {
      const [, type, name5] = prop.split(" ");
      properties.push({ name: name5, type, offset: rowOffset });
      if (offsets[type]) {
        rowOffset += offsets[type];
      } else {
        Logger.Error(`Unsupported property type: ${type}. Are you sure it's a valid Gaussian Splatting file?`);
        return new ArrayBuffer(0);
      }
    }
    const rowLength = 3 * 4 + 3 * 4 + 4 + 4;
    const SH_C0 = 0.28209479177387814;
    const dataView = new DataView(data, headerEndIndex + headerEnd.length);
    const buffer = new ArrayBuffer(rowLength * vertexCount);
    const q = new Quaternion();
    for (let i = 0; i < vertexCount; i++) {
      const position = new Float32Array(buffer, i * rowLength, 3);
      const scale = new Float32Array(buffer, i * rowLength + 12, 3);
      const rgba = new Uint8ClampedArray(buffer, i * rowLength + 24, 4);
      const rot = new Uint8ClampedArray(buffer, i * rowLength + 28, 4);
      let r0 = 255;
      let r1 = 0;
      let r2 = 0;
      let r3 = 0;
      for (let propertyIndex = 0; propertyIndex < properties.length; propertyIndex++) {
        const property = properties[propertyIndex];
        let value;
        switch (property.type) {
          case "float":
            value = dataView.getFloat32(property.offset + i * rowOffset, true);
            break;
          case "int":
            value = dataView.getInt32(property.offset + i * rowOffset, true);
            break;
          default:
            throw new Error(`Unsupported property type: ${property.type}`);
        }
        switch (property.name) {
          case "x":
            position[0] = value;
            break;
          case "y":
            position[1] = value;
            break;
          case "z":
            position[2] = value;
            break;
          case "scale_0":
            scale[0] = Math.exp(value);
            break;
          case "scale_1":
            scale[1] = Math.exp(value);
            break;
          case "scale_2":
            scale[2] = Math.exp(value);
            break;
          case "red":
            rgba[0] = value;
            break;
          case "green":
            rgba[1] = value;
            break;
          case "blue":
            rgba[2] = value;
            break;
          case "f_dc_0":
            rgba[0] = (0.5 + SH_C0 * value) * 255;
            break;
          case "f_dc_1":
            rgba[1] = (0.5 + SH_C0 * value) * 255;
            break;
          case "f_dc_2":
            rgba[2] = (0.5 + SH_C0 * value) * 255;
            break;
          case "f_dc_3":
            rgba[3] = (0.5 + SH_C0 * value) * 255;
            break;
          case "opacity":
            rgba[3] = 1 / (1 + Math.exp(-value)) * 255;
            break;
          case "rot_0":
            r0 = value;
            break;
          case "rot_1":
            r1 = value;
            break;
          case "rot_2":
            r2 = value;
            break;
          case "rot_3":
            r3 = value;
            break;
        }
      }
      q.set(r1, r2, r3, r0);
      q.normalize();
      rot[0] = q.w * 128 + 128;
      rot[1] = q.x * 128 + 128;
      rot[2] = q.y * 128 + 128;
      rot[3] = q.z * 128 + 128;
    }
    return buffer;
  }
  /**
   * Loads a .splat Gaussian Splatting array buffer asynchronously
   * @param data arraybuffer containing splat file
   * @returns a promise that resolves when the operation is complete
   */
  loadDataAsync(data) {
    return Promise.resolve(this._loadData(data));
  }
  /**
   * Loads a .splat Gaussian or .ply Splatting file asynchronously
   * @param url path to the splat file to load
   * @returns a promise that resolves when the operation is complete
   */
  loadFileAsync(url) {
    return Tools.LoadFileAsync(url, true).then((data) => {
      this._loadData(_GaussianSplattingMesh.ConvertPLYToSplat(data));
    });
  }
  /**
   * Releases resources associated with this mesh.
   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
   */
  dispose(doNotRecurse) {
    this._covariancesATexture?.dispose();
    this._covariancesBTexture?.dispose();
    this._centersTexture?.dispose();
    this._colorsTexture?.dispose();
    this._covariancesATexture = null;
    this._covariancesBTexture = null;
    this._centersTexture = null;
    this._colorsTexture = null;
    this._material?.dispose(false, true);
    this._material = null;
    this._worker?.terminate();
    this._worker = null;
    super.dispose(doNotRecurse);
  }
  _loadData(data) {
    if (!data.byteLength) {
      return;
    }
    const uBuffer = new Uint8Array(data);
    const fBuffer = new Float32Array(uBuffer.buffer);
    const rowLength = 3 * 4 + 3 * 4 + 4 + 4;
    const vertexCount = uBuffer.length / rowLength;
    this._vertexCount = vertexCount;
    const textureSize = this._getTextureSize(vertexCount);
    const textureLength = textureSize.x * textureSize.y;
    const positions = new Float32Array(3 * textureLength);
    const covA = new Float32Array(3 * textureLength);
    const covB = new Float32Array(3 * textureLength);
    const matrixRotation = TmpVectors.Matrix[0];
    const matrixScale = TmpVectors.Matrix[1];
    const quaternion = TmpVectors.Quaternion[0];
    const minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    const maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    for (let i = 0; i < vertexCount; i++) {
      const x = fBuffer[8 * i + 0];
      const y = -fBuffer[8 * i + 1];
      const z = fBuffer[8 * i + 2];
      positions[3 * i + 0] = x;
      positions[3 * i + 1] = y;
      positions[3 * i + 2] = z;
      minimum.minimizeInPlaceFromFloats(x, y, z);
      maximum.maximizeInPlaceFromFloats(x, y, z);
      quaternion.set((uBuffer[32 * i + 28 + 1] - 128) / 128, (uBuffer[32 * i + 28 + 2] - 128) / 128, (uBuffer[32 * i + 28 + 3] - 128) / 128, -(uBuffer[32 * i + 28 + 0] - 128) / 128);
      quaternion.toRotationMatrix(matrixRotation);
      Matrix.ScalingToRef(fBuffer[8 * i + 3 + 0] * 2, fBuffer[8 * i + 3 + 1] * 2, fBuffer[8 * i + 3 + 2] * 2, matrixScale);
      const M = matrixRotation.multiplyToRef(matrixScale, TmpVectors.Matrix[0]).m;
      covA[i * 3 + 0] = M[0] * M[0] + M[1] * M[1] + M[2] * M[2];
      covA[i * 3 + 1] = M[0] * M[4] + M[1] * M[5] + M[2] * M[6];
      covA[i * 3 + 2] = M[0] * M[8] + M[1] * M[9] + M[2] * M[10];
      covB[i * 3 + 0] = M[4] * M[4] + M[5] * M[5] + M[6] * M[6];
      covB[i * 3 + 1] = M[4] * M[8] + M[5] * M[9] + M[6] * M[10];
      covB[i * 3 + 2] = M[8] * M[8] + M[9] * M[9] + M[10] * M[10];
    }
    const binfo = this.getBoundingInfo();
    binfo.reConstruct(minimum, maximum, this.getWorldMatrix());
    binfo.isLocked = true;
    this.forcedInstanceCount = this._vertexCount;
    this.setEnabled(true);
    const splatIndex = new Float32Array(this._vertexCount * 1);
    this.thinInstanceSetBuffer("splatIndex", splatIndex, 1, false);
    const createTextureFromData = (data2, width, height, format) => {
      return new RawTexture(data2, width, height, format, this._scene, false, false, 2, 1);
    };
    const convertRgbToRgba = (rgb) => {
      const count = rgb.length / 3;
      const rgba = new Float32Array(count * 4);
      for (let i = 0; i < count; ++i) {
        rgba[i * 4 + 0] = rgb[i * 3 + 0];
        rgba[i * 4 + 1] = rgb[i * 3 + 1];
        rgba[i * 4 + 2] = rgb[i * 3 + 2];
        rgba[i * 4 + 3] = 1;
      }
      return rgba;
    };
    const colorArray = new Float32Array(textureSize.x * textureSize.y * 4);
    for (let i = 0; i < this._vertexCount; ++i) {
      colorArray[i * 4 + 0] = uBuffer[32 * i + 24 + 0] / 255;
      colorArray[i * 4 + 1] = uBuffer[32 * i + 24 + 1] / 255;
      colorArray[i * 4 + 2] = uBuffer[32 * i + 24 + 2] / 255;
      colorArray[i * 4 + 3] = uBuffer[32 * i + 24 + 3] / 255;
    }
    this._covariancesATexture = createTextureFromData(convertRgbToRgba(covA), textureSize.x, textureSize.y, 5);
    this._covariancesBTexture = createTextureFromData(convertRgbToRgba(covB), textureSize.x, textureSize.y, 5);
    this._centersTexture = createTextureFromData(convertRgbToRgba(positions), textureSize.x, textureSize.y, 5);
    this._colorsTexture = createTextureFromData(colorArray, textureSize.x, textureSize.y, 5);
    this._worker?.terminate();
    this._worker = new Worker(URL.createObjectURL(new Blob(["(", _GaussianSplattingMesh._CreateWorker.toString(), ")(self)"], {
      type: "application/javascript"
    })));
    this._depthMix = new BigInt64Array(vertexCount);
    this._worker.postMessage({ positions, vertexCount }, [positions.buffer]);
    this._worker.onmessage = (e) => {
      this._depthMix = e.data.depthMix;
      const indexMix = new Uint32Array(e.data.depthMix.buffer);
      for (let j = 0; j < this._vertexCount; j++) {
        splatIndex[j] = indexMix[2 * j];
      }
      this.thinInstanceBufferUpdated("splatIndex");
      this._canPostToWorker = true;
    };
  }
  _getTextureSize(length) {
    const engine = this._scene.getEngine();
    const width = engine.getCaps().maxTextureSize;
    let height = 1;
    if (engine.webGLVersion === 1 && !engine.isWebGPU) {
      while (width * height < length) {
        height *= 2;
      }
    } else {
      height = Math.ceil(length / width);
    }
    if (height > width) {
      Logger.Error("GaussianSplatting texture size: (" + width + ", " + height + "), maxTextureSize: " + width);
      height = width;
    }
    return new Vector2(width, height);
  }
};
GaussianSplattingMesh._CreateWorker = function(self) {
  let vertexCount = 0;
  let positions;
  let depthMix;
  let indices;
  let floatMix;
  self.onmessage = (e) => {
    if (e.data.positions) {
      positions = e.data.positions;
      vertexCount = e.data.vertexCount;
    } else {
      const viewProj = e.data.view;
      if (!positions || !viewProj) {
        throw new Error("positions or view is not defined!");
      }
      depthMix = e.data.depthMix;
      indices = new Uint32Array(depthMix.buffer);
      floatMix = new Float32Array(depthMix.buffer);
      for (let j = 0; j < vertexCount; j++) {
        indices[2 * j] = j;
      }
      for (let j = 0; j < vertexCount; j++) {
        floatMix[2 * j + 1] = 1e4 - (viewProj[2] * positions[3 * j + 0] + viewProj[6] * positions[3 * j + 1] + viewProj[10] * positions[3 * j + 2]);
      }
      depthMix.sort();
      self.postMessage({ depthMix }, [depthMix.buffer]);
    }
  };
};

export {
  GaussianSplattingMaterial,
  GaussianSplattingMesh
};
//# sourceMappingURL=chunk-HKWCCOKM.js.map

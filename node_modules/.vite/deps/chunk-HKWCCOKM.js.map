{
  "version": 3,
  "sources": ["../../../dev/core/src/Shaders/gaussianSplatting.fragment.ts", "../../../dev/core/src/Shaders/ShadersInclude/gaussianSplattingVertexDeclaration.ts", "../../../dev/core/src/Shaders/ShadersInclude/gaussianSplattingUboDeclaration.ts", "../../../dev/core/src/Shaders/gaussianSplatting.vertex.ts", "../../../dev/core/src/Materials/GaussianSplatting/gaussianSplattingMaterial.ts", "../../../dev/core/src/Meshes/GaussianSplatting/gaussianSplattingMesh.ts"],
  "sourcesContent": ["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/fogFragmentDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragment\";\nimport \"./ShadersInclude/logDepthFragment\";\nimport \"./ShadersInclude/fogFragment\";\n\nconst name = \"gaussianSplattingPixelShader\";\nconst shader = `#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\nvarying vec4 vColor;varying vec2 vPosition;void main () { \n#include<clipPlaneFragment>\nfloat A=-dot(vPosition,vPosition);if (A<-4.0) discard;float B=exp(A)*vColor.a;\n#include<logDepthFragment>\nvec3 color=vColor.rgb;\n#ifdef FOG\n#include<fogFragment>\n#endif\ngl_FragColor=vec4(color,B);}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const gaussianSplattingPixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"gaussianSplattingVertexDeclaration\";\nconst shader = `uniform mat4 world;uniform mat4 view;uniform mat4 projection;\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const gaussianSplattingVertexDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nimport \"./sceneUboDeclaration\";\nimport \"./meshUboDeclaration\";\n\nconst name = \"gaussianSplattingUboDeclaration\";\nconst shader = `#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const gaussianSplattingUboDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/gaussianSplattingVertexDeclaration\";\nimport \"./ShadersInclude/gaussianSplattingUboDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/fogVertexDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/fogVertex\";\nimport \"./ShadersInclude/logDepthVertex\";\n\nconst name = \"gaussianSplattingVertexShader\";\nconst shader = `#include<__decl__gaussianSplattingVertex>\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<logDepthDeclaration>\nattribute vec2 position;attribute float splatIndex;uniform vec2 viewport;uniform vec2 dataTextureSize;uniform vec2 focal;uniform sampler2D covariancesATexture;uniform sampler2D covariancesBTexture;uniform sampler2D centersTexture;uniform sampler2D colorsTexture;varying vec4 vColor;varying vec2 vPosition;\n#if !defined(WEBGL2) && !defined(WEBGPU) && !defined(NATIVE)\nmat3 transpose(mat3 matrix) {return mat3(matrix[0][0],matrix[1][0],matrix[2][0],\nmatrix[0][1],matrix[1][1],matrix[2][1],\nmatrix[0][2],matrix[1][2],matrix[2][2]);}\n#endif\nvec2 getDataUV(float index,vec2 textureSize) {float y=floor(index/textureSize.x);float x=index-y*textureSize.x;return vec2((x+0.5)/textureSize.x,(y+0.5)/textureSize.y);}\nvoid main () {vec2 splatUV=getDataUV(splatIndex,dataTextureSize);vec3 center=texture2D(centersTexture,splatUV).xyz;vec4 color=texture2D(colorsTexture,splatUV);vec3 covA=texture2D(covariancesATexture,splatUV).xyz;vec3 covB=texture2D(covariancesBTexture,splatUV).xyz;vec4 worldPos=world*vec4(center,1.0);mat4 modelView=view*world;vec4 camspace=view*worldPos;vec4 pos2d=projection*camspace;float bounds=1.2*pos2d.w;if (pos2d.z<-pos2d.w || pos2d.x<-bounds || pos2d.x>bounds\n|| pos2d.y<-bounds || pos2d.y>bounds) {gl_Position=vec4(0.0,0.0,2.0,1.0);return;}\nmat3 Vrk=mat3(\ncovA.x,covA.y,covA.z,\ncovA.y,covB.x,covB.y,\ncovA.z,covB.y,covB.z\n);mat3 J=mat3(\nfocal.x/camspace.z,0.,-(focal.x*camspace.x)/(camspace.z*camspace.z),\n0.,focal.y/camspace.z,-(focal.y*camspace.y)/(camspace.z*camspace.z),\n0.,0.,0.\n);mat3 invy=mat3(1,0,0,0,-1,0,0,0,1);mat3 T=invy*transpose(mat3(modelView))*J;mat3 cov2d=transpose(T)*Vrk*T;float mid=(cov2d[0][0]+cov2d[1][1])/2.0;float radius=length(vec2((cov2d[0][0]-cov2d[1][1])/2.0,cov2d[0][1]));float lambda1=mid+radius,lambda2=mid-radius;if (lambda2<0.0) return;vec2 diagonalVector=normalize(vec2(cov2d[0][1],lambda1-cov2d[0][0]));vec2 majorAxis=min(sqrt(2.0*lambda1),1024.0)*diagonalVector;vec2 minorAxis=min(sqrt(2.0*lambda2),1024.0)*vec2(diagonalVector.y,-diagonalVector.x);vColor=color;vPosition=position;vec2 vCenter=vec2(pos2d);gl_Position=vec4(\nvCenter \n+ (position.x*majorAxis*1./viewport \n+ position.y*minorAxis*1./viewport)*pos2d.w,pos2d.zw);\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<logDepthVertex>\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const gaussianSplattingVertexShader = { name, shader };\n", "import type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { IEffectCreationOptions } from \"../../Materials/effect\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport type { GaussianSplattingMesh } from \"core/Meshes\";\r\nimport { SerializationHelper } from \"../../Misc/decorators.serialization\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { MaterialDefines } from \"../../Materials/materialDefines\";\r\nimport { PushMaterial } from \"../../Materials/pushMaterial\";\r\nimport { RegisterClass } from \"../../Misc/typeStore\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"../clipPlaneMaterialHelper\";\r\nimport { Camera } from \"core/Cameras/camera\";\r\n\r\nimport \"../../Shaders/gaussianSplatting.fragment\";\r\nimport \"../../Shaders/gaussianSplatting.vertex\";\r\nimport {\r\n    BindFogParameters,\r\n    BindLogDepth,\r\n    PrepareAttributesForInstances,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForMisc,\r\n    PrepareUniformsAndSamplersList,\r\n} from \"../materialHelper.functions\";\r\n\r\n/**\r\n * @internal\r\n */\r\nclass GaussianSplattingMaterialDefines extends MaterialDefines {\r\n    public FOG = false;\r\n    public THIN_INSTANCES = true;\r\n    public LOGARITHMICDEPTH = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n\r\n    /**\r\n     * Constructor of the defines.\r\n     */\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\n/**\r\n * GaussianSplattingMaterial material used to render Gaussian Splatting\r\n * @experimental\r\n */\r\nexport class GaussianSplattingMaterial extends PushMaterial {\r\n    /**\r\n     * Instantiates a Gaussian Splatting Material in the given scene\r\n     * @param name The friendly name of the material\r\n     * @param scene The scene to add the material to\r\n     */\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n\r\n        this.backFaceCulling = false;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     */\r\n    public get hasRenderTargetTextures(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not this material should be rendered in alpha test mode.\r\n     * @returns false\r\n     */\r\n    public needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not this material should be rendered in alpha blend mode.\r\n     * @returns true\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks whether the material is ready to be rendered for a given mesh.\r\n     * @param mesh The mesh to render\r\n     * @param subMesh The submesh to check against\r\n     * @returns true if all the dependencies are ready (Textures, Effects...)\r\n     */\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh): boolean {\r\n        const useInstances = true;\r\n\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (drawWrapper.effect && this.isFrozen) {\r\n            if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new GaussianSplattingMaterialDefines();\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        const defines = <GaussianSplattingMaterialDefines>subMesh.materialDefines;\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Misc.\r\n        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, false, defines);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances, null, true);\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, false, false);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind, \"splatIndex\"];\r\n\r\n            PrepareAttributesForInstances(attribs, defines);\r\n\r\n            const uniforms = [\"world\", \"view\", \"projection\", \"vFogInfos\", \"vFogColor\", \"logarithmicDepthConstant\", \"viewport\", \"dataTextureSize\", \"focal\"];\r\n            const samplers = [\"covariancesATexture\", \"covariancesBTexture\", \"centersTexture\", \"colorsTexture\"];\r\n            const uniformBuffers = [\"Scene\", \"Mesh\"];\r\n\r\n            PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n            });\r\n\r\n            addClipPlaneUniforms(uniforms);\r\n\r\n            const join = defines.toString();\r\n            const effect = scene.getEngine().createEffect(\r\n                \"gaussianSplatting\",\r\n                <IEffectCreationOptions>{\r\n                    attributes: attribs,\r\n                    uniformsNames: uniforms,\r\n                    uniformBuffersNames: uniformBuffers,\r\n                    samplers: samplers,\r\n                    defines: join,\r\n                    onCompiled: this.onCompiled,\r\n                    onError: this.onError,\r\n                },\r\n                engine\r\n            );\r\n            subMesh.setEffect(effect, defines, this._materialContext);\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n        drawWrapper._wasPreviouslyUsingInstances = useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh to this material by preparing the effect and shader to draw\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <GaussianSplattingMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices Mesh.\r\n        mesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\r\n        mesh.transferToEffect(world);\r\n\r\n        // Bind data\r\n        const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);\r\n\r\n        if (mustRebind) {\r\n            this.bindView(effect);\r\n            this.bindViewProjection(effect);\r\n\r\n            const engine = scene.getEngine();\r\n            const camera = this.getScene().activeCamera;\r\n\r\n            const renderWidth = engine.getRenderWidth();\r\n            const renderHeight = engine.getRenderHeight();\r\n\r\n            this._activeEffect.setFloat2(\"viewport\", renderWidth, renderHeight);\r\n\r\n            let focal = 1000;\r\n\r\n            if (camera) {\r\n                if (camera.fovMode == Camera.FOVMODE_VERTICAL_FIXED) {\r\n                    focal = renderHeight / 2.0 / Math.tan(camera.fov / 2.0);\r\n                } else {\r\n                    focal = renderWidth / 2.0 / Math.tan(camera.fov / 2.0);\r\n                }\r\n            }\r\n\r\n            this._activeEffect.setFloat2(\"focal\", focal, focal);\r\n\r\n            const gsMesh = mesh as GaussianSplattingMesh;\r\n\r\n            if (gsMesh.covariancesATexture) {\r\n                const textureSize = gsMesh.covariancesATexture.getSize();\r\n\r\n                effect.setFloat2(\"dataTextureSize\", textureSize.width, textureSize.height);\r\n\r\n                effect.setTexture(\"covariancesATexture\", gsMesh.covariancesATexture);\r\n                effect.setTexture(\"covariancesBTexture\", gsMesh.covariancesBTexture);\r\n                effect.setTexture(\"centersTexture\", gsMesh.centersTexture);\r\n                effect.setTexture(\"colorsTexture\", gsMesh.colorsTexture);\r\n            }\r\n\r\n            // Clip plane\r\n            bindClipPlane(effect, this, scene);\r\n        } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {\r\n            this._needToBindSceneUbo = true;\r\n        }\r\n\r\n        // Fog\r\n        BindFogParameters(scene, mesh, effect);\r\n\r\n        // Log. depth\r\n        if (this.useLogarithmicDepth) {\r\n            BindLogDepth(defines, effect, scene);\r\n        }\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    /**\r\n     * Clones the material.\r\n     * @param name The cloned name.\r\n     * @returns The cloned material.\r\n     */\r\n    public clone(name: string): GaussianSplattingMaterial {\r\n        return SerializationHelper.Clone(() => new GaussianSplattingMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    /**\r\n     * Serializes the current material to its JSON representation.\r\n     * @returns The JSON representation.\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.GaussianSplattingMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the material\r\n     * @returns \"GaussianSplattingMaterial\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"GaussianSplattingMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Parse a JSON input to create back a Gaussian Splatting material.\r\n     * @param source The JSON data to parse\r\n     * @param scene The scene to create the parsed material in\r\n     * @param rootUrl The root url of the assets the material depends upon\r\n     * @returns the instantiated GaussianSplattingMaterial.\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): GaussianSplattingMaterial {\r\n        return SerializationHelper.Parse(() => new GaussianSplattingMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GaussianSplattingMaterial\", GaussianSplattingMaterial);\r\n", "import type { Scene } from \"core/scene\";\r\nimport type { DeepImmutable, Nullable } from \"core/types\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { SubMesh } from \"../subMesh\";\r\nimport type { AbstractMesh } from \"../abstractMesh\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { Matrix, TmpVectors, Vector2, Vector3, Quaternion } from \"core/Maths/math.vector\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { GaussianSplattingMaterial } from \"core/Materials/GaussianSplatting/gaussianSplattingMaterial\";\r\nimport { RawTexture } from \"core/Materials/Textures/rawTexture\";\r\nimport { Constants } from \"core/Engines/constants\";\r\n\r\n/**\r\n * Class used to render a gaussian splatting mesh\r\n */\r\nexport class GaussianSplattingMesh extends Mesh {\r\n    private _vertexCount = 0;\r\n    private _worker: Nullable<Worker> = null;\r\n    private _frameIdLastUpdate = -1;\r\n    private _modelViewMatrix = Matrix.Identity();\r\n    private _material: Nullable<GaussianSplattingMaterial> = null;\r\n    private _depthMix: BigInt64Array;\r\n    private _canPostToWorker = true;\r\n    private _lastProj: DeepImmutable<Float32Array | number[]>;\r\n    private _covariancesATexture: Nullable<BaseTexture> = null;\r\n    private _covariancesBTexture: Nullable<BaseTexture> = null;\r\n    private _centersTexture: Nullable<BaseTexture> = null;\r\n    private _colorsTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Gets the covariancesA texture\r\n     */\r\n    public get covariancesATexture() {\r\n        return this._covariancesATexture;\r\n    }\r\n\r\n    /**\r\n     * Gets the covariancesB texture\r\n     */\r\n    public get covariancesBTexture() {\r\n        return this._covariancesBTexture;\r\n    }\r\n\r\n    /**\r\n     * Gets the centers texture\r\n     */\r\n    public get centersTexture() {\r\n        return this._centersTexture;\r\n    }\r\n\r\n    /**\r\n     * Gets the colors texture\r\n     */\r\n    public get colorsTexture() {\r\n        return this._colorsTexture;\r\n    }\r\n\r\n    /**\r\n     * Creates a new gaussian splatting mesh\r\n     * @param name defines the name of the mesh\r\n     * @param url defines the url to load from (optional)\r\n     * @param scene defines the hosting scene (optional)\r\n     */\r\n    constructor(name: string, url: Nullable<string> = null, scene: Nullable<Scene> = null) {\r\n        super(name, scene);\r\n\r\n        const vertexData = new VertexData();\r\n\r\n        vertexData.positions = [-2, -2, 0, 2, -2, 0, 2, 2, 0, -2, 2, 0];\r\n        vertexData.indices = [0, 1, 2, 0, 2, 3];\r\n        vertexData.applyToMesh(this);\r\n\r\n        this.subMeshes = [];\r\n        new SubMesh(0, 0, 4, 0, 6, this);\r\n\r\n        this.doNotSyncBoundingInfo = true;\r\n        this.setEnabled(false);\r\n\r\n        this._lastProj = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\r\n\r\n        if (url) {\r\n            this.loadFileAsync(url);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the class name\r\n     * @returns \"GaussianSplattingMesh\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"GaussianSplattingMesh\";\r\n    }\r\n\r\n    /**\r\n     * Returns the total number of vertices (splats) within the mesh\r\n     * @returns the total number of vertices\r\n     */\r\n    public getTotalVertices(): number {\r\n        return this._vertexCount;\r\n    }\r\n\r\n    /**\r\n     * Triggers the draw call for the mesh. Usually, you don't need to call this method by your own because the mesh rendering is handled by the scene rendering manager\r\n     * @param subMesh defines the subMesh to render\r\n     * @param enableAlphaMode defines if alpha mode can be changed\r\n     * @param effectiveMeshReplacement defines an optional mesh used to provide info for the rendering\r\n     * @returns the current mesh\r\n     */\r\n    public render(subMesh: SubMesh, enableAlphaMode: boolean, effectiveMeshReplacement?: AbstractMesh): Mesh {\r\n        if (!this.material) {\r\n            this._material = new GaussianSplattingMaterial(this.name + \"_material\", this._scene);\r\n            this.material = this._material;\r\n        }\r\n\r\n        const frameId = this.getScene().getFrameId();\r\n        if (frameId !== this._frameIdLastUpdate && this._worker && this._scene.activeCamera && this._canPostToWorker) {\r\n            this.getWorldMatrix().multiplyToRef(this._scene.activeCamera.getViewMatrix(), this._modelViewMatrix);\r\n\r\n            const dot = this._lastProj[2] * this._modelViewMatrix.m[2] + this._lastProj[6] * this._modelViewMatrix.m[6] + this._lastProj[10] * this._modelViewMatrix.m[10];\r\n            if (Math.abs(dot - 1) >= 0.01) {\r\n                this._frameIdLastUpdate = frameId;\r\n                this._canPostToWorker = false;\r\n                this._lastProj = this._modelViewMatrix.m.slice(0);\r\n                this._worker.postMessage({ view: this._modelViewMatrix.m, depthMix: this._depthMix }, [this._depthMix.buffer]);\r\n            }\r\n        }\r\n\r\n        return super.render(subMesh, enableAlphaMode, effectiveMeshReplacement);\r\n    }\r\n\r\n    /**\r\n     * Code from https://github.com/dylanebert/gsplat.js/blob/main/src/loaders/PLYLoader.ts Under MIT license\r\n     * Converts a .ply data array buffer to splat\r\n     * if data array buffer is not ply, returns the original buffer\r\n     * @param data the .ply data to load\r\n     * @returns the loaded splat buffer\r\n     */\r\n    public static ConvertPLYToSplat(data: ArrayBuffer): ArrayBuffer {\r\n        const ubuf = new Uint8Array(data);\r\n        const header = new TextDecoder().decode(ubuf.slice(0, 1024 * 10));\r\n        const headerEnd = \"end_header\\n\";\r\n        const headerEndIndex = header.indexOf(headerEnd);\r\n        if (headerEndIndex < 0 || !header) {\r\n            return data;\r\n        }\r\n        const vertexCount = parseInt(/element vertex (\\d+)\\n/.exec(header)![1]);\r\n\r\n        let rowOffset = 0;\r\n        const offsets: Record<string, number> = {\r\n            double: 8,\r\n            int: 4,\r\n            uint: 4,\r\n            float: 4,\r\n            short: 2,\r\n            ushort: 2,\r\n            uchar: 1,\r\n        };\r\n\r\n        type PlyProperty = {\r\n            name: string;\r\n            type: string;\r\n            offset: number;\r\n        };\r\n        const properties: PlyProperty[] = [];\r\n        const filtered = header\r\n            .slice(0, headerEndIndex)\r\n            .split(\"\\n\")\r\n            .filter((k) => k.startsWith(\"property \"));\r\n        for (const prop of filtered) {\r\n            const [, type, name] = prop.split(\" \");\r\n            properties.push({ name, type, offset: rowOffset });\r\n            if (offsets[type]) {\r\n                rowOffset += offsets[type];\r\n            } else {\r\n                Logger.Error(`Unsupported property type: ${type}. Are you sure it's a valid Gaussian Splatting file?`);\r\n                return new ArrayBuffer(0);\r\n            }\r\n        }\r\n\r\n        const rowLength = 3 * 4 + 3 * 4 + 4 + 4;\r\n        const SH_C0 = 0.28209479177387814;\r\n\r\n        const dataView = new DataView(data, headerEndIndex + headerEnd.length);\r\n        const buffer = new ArrayBuffer(rowLength * vertexCount);\r\n        const q = new Quaternion();\r\n\r\n        for (let i = 0; i < vertexCount; i++) {\r\n            const position = new Float32Array(buffer, i * rowLength, 3);\r\n            const scale = new Float32Array(buffer, i * rowLength + 12, 3);\r\n            const rgba = new Uint8ClampedArray(buffer, i * rowLength + 24, 4);\r\n            const rot = new Uint8ClampedArray(buffer, i * rowLength + 28, 4);\r\n\r\n            let r0: number = 255;\r\n            let r1: number = 0;\r\n            let r2: number = 0;\r\n            let r3: number = 0;\r\n\r\n            for (let propertyIndex = 0; propertyIndex < properties.length; propertyIndex++) {\r\n                const property = properties[propertyIndex];\r\n                let value;\r\n                switch (property.type) {\r\n                    case \"float\":\r\n                        value = dataView.getFloat32(property.offset + i * rowOffset, true);\r\n                        break;\r\n                    case \"int\":\r\n                        value = dataView.getInt32(property.offset + i * rowOffset, true);\r\n                        break;\r\n                    default:\r\n                        throw new Error(`Unsupported property type: ${property.type}`);\r\n                }\r\n\r\n                switch (property.name) {\r\n                    case \"x\":\r\n                        position[0] = value;\r\n                        break;\r\n                    case \"y\":\r\n                        position[1] = value;\r\n                        break;\r\n                    case \"z\":\r\n                        position[2] = value;\r\n                        break;\r\n                    case \"scale_0\":\r\n                        scale[0] = Math.exp(value);\r\n                        break;\r\n                    case \"scale_1\":\r\n                        scale[1] = Math.exp(value);\r\n                        break;\r\n                    case \"scale_2\":\r\n                        scale[2] = Math.exp(value);\r\n                        break;\r\n                    case \"red\":\r\n                        rgba[0] = value;\r\n                        break;\r\n                    case \"green\":\r\n                        rgba[1] = value;\r\n                        break;\r\n                    case \"blue\":\r\n                        rgba[2] = value;\r\n                        break;\r\n                    case \"f_dc_0\":\r\n                        rgba[0] = (0.5 + SH_C0 * value) * 255;\r\n                        break;\r\n                    case \"f_dc_1\":\r\n                        rgba[1] = (0.5 + SH_C0 * value) * 255;\r\n                        break;\r\n                    case \"f_dc_2\":\r\n                        rgba[2] = (0.5 + SH_C0 * value) * 255;\r\n                        break;\r\n                    case \"f_dc_3\":\r\n                        rgba[3] = (0.5 + SH_C0 * value) * 255;\r\n                        break;\r\n                    case \"opacity\":\r\n                        rgba[3] = (1 / (1 + Math.exp(-value))) * 255;\r\n                        break;\r\n                    case \"rot_0\":\r\n                        r0 = value;\r\n                        break;\r\n                    case \"rot_1\":\r\n                        r1 = value;\r\n                        break;\r\n                    case \"rot_2\":\r\n                        r2 = value;\r\n                        break;\r\n                    case \"rot_3\":\r\n                        r3 = value;\r\n                        break;\r\n                }\r\n            }\r\n\r\n            q.set(r1, r2, r3, r0);\r\n            q.normalize();\r\n            rot[0] = q.w * 128 + 128;\r\n            rot[1] = q.x * 128 + 128;\r\n            rot[2] = q.y * 128 + 128;\r\n            rot[3] = q.z * 128 + 128;\r\n        }\r\n\r\n        return buffer;\r\n    }\r\n\r\n    /**\r\n     * Loads a .splat Gaussian Splatting array buffer asynchronously\r\n     * @param data arraybuffer containing splat file\r\n     * @returns a promise that resolves when the operation is complete\r\n     */\r\n\r\n    public loadDataAsync(data: ArrayBuffer): Promise<void> {\r\n        return Promise.resolve(this._loadData(data));\r\n    }\r\n\r\n    /**\r\n     * Loads a .splat Gaussian or .ply Splatting file asynchronously\r\n     * @param url path to the splat file to load\r\n     * @returns a promise that resolves when the operation is complete\r\n     */\r\n    public loadFileAsync(url: string): Promise<void> {\r\n        return Tools.LoadFileAsync(url, true).then((data) => {\r\n            this._loadData(GaussianSplattingMesh.ConvertPLYToSplat(data));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Releases resources associated with this mesh.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     */\r\n    public dispose(doNotRecurse?: boolean): void {\r\n        this._covariancesATexture?.dispose();\r\n        this._covariancesBTexture?.dispose();\r\n        this._centersTexture?.dispose();\r\n        this._colorsTexture?.dispose();\r\n\r\n        this._covariancesATexture = null;\r\n        this._covariancesBTexture = null;\r\n        this._centersTexture = null;\r\n        this._colorsTexture = null;\r\n\r\n        this._material?.dispose(false, true);\r\n        this._material = null;\r\n\r\n        this._worker?.terminate();\r\n        this._worker = null;\r\n\r\n        super.dispose(doNotRecurse);\r\n    }\r\n\r\n    private static _CreateWorker = function (self: Worker) {\r\n        let vertexCount = 0;\r\n        let positions: Float32Array;\r\n        let depthMix: BigInt64Array;\r\n        let indices: Uint32Array;\r\n        let floatMix: Float32Array;\r\n\r\n        self.onmessage = (e: any) => {\r\n            // updated on init\r\n            if (e.data.positions) {\r\n                positions = e.data.positions;\r\n                vertexCount = e.data.vertexCount;\r\n            }\r\n            // udpate on view changed\r\n            else {\r\n                const viewProj = e.data.view;\r\n                if (!positions || !viewProj) {\r\n                    // Sanity check, it shouldn't happen!\r\n                    throw new Error(\"positions or view is not defined!\");\r\n                }\r\n\r\n                depthMix = e.data.depthMix;\r\n                indices = new Uint32Array(depthMix.buffer);\r\n                floatMix = new Float32Array(depthMix.buffer);\r\n\r\n                // Sort\r\n                for (let j = 0; j < vertexCount; j++) {\r\n                    indices[2 * j] = j;\r\n                }\r\n\r\n                for (let j = 0; j < vertexCount; j++) {\r\n                    floatMix[2 * j + 1] = 10000 - (viewProj[2] * positions[3 * j + 0] + viewProj[6] * positions[3 * j + 1] + viewProj[10] * positions[3 * j + 2]);\r\n                }\r\n\r\n                depthMix.sort();\r\n\r\n                self.postMessage({ depthMix }, [depthMix.buffer]);\r\n            }\r\n        };\r\n    };\r\n\r\n    private _loadData(data: ArrayBuffer): void {\r\n        if (!data.byteLength) {\r\n            return;\r\n        }\r\n        // Parse the data\r\n        const uBuffer = new Uint8Array(data);\r\n        const fBuffer = new Float32Array(uBuffer.buffer);\r\n\r\n        const rowLength = 3 * 4 + 3 * 4 + 4 + 4;\r\n        const vertexCount = uBuffer.length / rowLength;\r\n\r\n        this._vertexCount = vertexCount;\r\n\r\n        const textureSize = this._getTextureSize(vertexCount);\r\n        const textureLength = textureSize.x * textureSize.y;\r\n\r\n        const positions = new Float32Array(3 * textureLength);\r\n        const covA = new Float32Array(3 * textureLength);\r\n        const covB = new Float32Array(3 * textureLength);\r\n\r\n        const matrixRotation = TmpVectors.Matrix[0];\r\n        const matrixScale = TmpVectors.Matrix[1];\r\n        const quaternion = TmpVectors.Quaternion[0];\r\n\r\n        const minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        const maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n        for (let i = 0; i < vertexCount; i++) {\r\n            const x = fBuffer[8 * i + 0];\r\n            const y = -fBuffer[8 * i + 1];\r\n            const z = fBuffer[8 * i + 2];\r\n\r\n            positions[3 * i + 0] = x;\r\n            positions[3 * i + 1] = y;\r\n            positions[3 * i + 2] = z;\r\n\r\n            minimum.minimizeInPlaceFromFloats(x, y, z);\r\n            maximum.maximizeInPlaceFromFloats(x, y, z);\r\n\r\n            quaternion.set(\r\n                (uBuffer[32 * i + 28 + 1] - 128) / 128,\r\n                (uBuffer[32 * i + 28 + 2] - 128) / 128,\r\n                (uBuffer[32 * i + 28 + 3] - 128) / 128,\r\n                -(uBuffer[32 * i + 28 + 0] - 128) / 128\r\n            );\r\n            quaternion.toRotationMatrix(matrixRotation);\r\n\r\n            Matrix.ScalingToRef(fBuffer[8 * i + 3 + 0] * 2, fBuffer[8 * i + 3 + 1] * 2, fBuffer[8 * i + 3 + 2] * 2, matrixScale);\r\n\r\n            const M = matrixRotation.multiplyToRef(matrixScale, TmpVectors.Matrix[0]).m;\r\n\r\n            covA[i * 3 + 0] = M[0] * M[0] + M[1] * M[1] + M[2] * M[2];\r\n            covA[i * 3 + 1] = M[0] * M[4] + M[1] * M[5] + M[2] * M[6];\r\n            covA[i * 3 + 2] = M[0] * M[8] + M[1] * M[9] + M[2] * M[10];\r\n            covB[i * 3 + 0] = M[4] * M[4] + M[5] * M[5] + M[6] * M[6];\r\n            covB[i * 3 + 1] = M[4] * M[8] + M[5] * M[9] + M[6] * M[10];\r\n            covB[i * 3 + 2] = M[8] * M[8] + M[9] * M[9] + M[10] * M[10];\r\n        }\r\n\r\n        // Update the mesh\r\n        const binfo = this.getBoundingInfo();\r\n        binfo.reConstruct(minimum, maximum, this.getWorldMatrix());\r\n        binfo.isLocked = true;\r\n\r\n        this.forcedInstanceCount = this._vertexCount;\r\n        this.setEnabled(true);\r\n\r\n        const splatIndex = new Float32Array(this._vertexCount * 1);\r\n\r\n        this.thinInstanceSetBuffer(\"splatIndex\", splatIndex, 1, false);\r\n\r\n        // Update the material\r\n        const createTextureFromData = (data: Float32Array, width: number, height: number, format: number) => {\r\n            return new RawTexture(data, width, height, format, this._scene, false, false, Constants.TEXTURE_BILINEAR_SAMPLINGMODE, Constants.TEXTURETYPE_FLOAT);\r\n        };\r\n\r\n        const convertRgbToRgba = (rgb: Float32Array) => {\r\n            const count = rgb.length / 3;\r\n            const rgba = new Float32Array(count * 4);\r\n            for (let i = 0; i < count; ++i) {\r\n                rgba[i * 4 + 0] = rgb[i * 3 + 0];\r\n                rgba[i * 4 + 1] = rgb[i * 3 + 1];\r\n                rgba[i * 4 + 2] = rgb[i * 3 + 2];\r\n                rgba[i * 4 + 3] = 1.0;\r\n            }\r\n            return rgba;\r\n        };\r\n\r\n        const colorArray = new Float32Array(textureSize.x * textureSize.y * 4);\r\n        for (let i = 0; i < this._vertexCount; ++i) {\r\n            colorArray[i * 4 + 0] = uBuffer[32 * i + 24 + 0] / 255;\r\n            colorArray[i * 4 + 1] = uBuffer[32 * i + 24 + 1] / 255;\r\n            colorArray[i * 4 + 2] = uBuffer[32 * i + 24 + 2] / 255;\r\n            colorArray[i * 4 + 3] = uBuffer[32 * i + 24 + 3] / 255;\r\n        }\r\n\r\n        this._covariancesATexture = createTextureFromData(convertRgbToRgba(covA), textureSize.x, textureSize.y, Constants.TEXTUREFORMAT_RGBA);\r\n        this._covariancesBTexture = createTextureFromData(convertRgbToRgba(covB), textureSize.x, textureSize.y, Constants.TEXTUREFORMAT_RGBA);\r\n        this._centersTexture = createTextureFromData(convertRgbToRgba(positions), textureSize.x, textureSize.y, Constants.TEXTUREFORMAT_RGBA);\r\n        this._colorsTexture = createTextureFromData(colorArray, textureSize.x, textureSize.y, Constants.TEXTUREFORMAT_RGBA);\r\n\r\n        // Start the worker thread\r\n        this._worker?.terminate();\r\n        this._worker = new Worker(\r\n            URL.createObjectURL(\r\n                new Blob([\"(\", GaussianSplattingMesh._CreateWorker.toString(), \")(self)\"], {\r\n                    type: \"application/javascript\",\r\n                })\r\n            )\r\n        );\r\n\r\n        this._depthMix = new BigInt64Array(vertexCount);\r\n\r\n        this._worker.postMessage({ positions, vertexCount }, [positions.buffer]);\r\n\r\n        this._worker.onmessage = (e) => {\r\n            this._depthMix = e.data.depthMix;\r\n            const indexMix = new Uint32Array(e.data.depthMix.buffer);\r\n            for (let j = 0; j < this._vertexCount; j++) {\r\n                splatIndex[j] = indexMix[2 * j];\r\n            }\r\n            this.thinInstanceBufferUpdated(\"splatIndex\");\r\n            this._canPostToWorker = true;\r\n        };\r\n    }\r\n\r\n    private _getTextureSize(length: number): Vector2 {\r\n        const engine = this._scene.getEngine();\r\n        const width = engine.getCaps().maxTextureSize;\r\n\r\n        let height = 1;\r\n\r\n        if (engine.webGLVersion === 1 && !engine.isWebGPU) {\r\n            while (width * height < length) {\r\n                height *= 2;\r\n            }\r\n        } else {\r\n            height = Math.ceil(length / width);\r\n        }\r\n\r\n        if (height > width) {\r\n            Logger.Error(\"GaussianSplatting texture size: (\" + width + \", \" + height + \"), maxTextureSize: \" + width);\r\n            height = width;\r\n        }\r\n\r\n        return new Vector2(width, height);\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["name", "shader", "name", "shader", "name", "shader", "name", "name", "data"]
}
